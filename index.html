<html>
    <head>
        <title>Map Maker</title>
        <script src="js/snap.svg-min.js"></script>
        <script src="js/pathfinding-browser.min.js"></script>
    </head>
    <body>
        <script>
            var s = Snap(1024,768);
            var g_l0, g_l1, g_l2, g_l3, g_bBox;
            s.root.node.id = "svgroot";
            Snap.load("svg/WalkwaysEd.svg", function (frag) {
                // var allg = frag.selectAll(); // If we want to select all groups in SVG
                g_l1 = frag.select("#Layer_1");
                s.append(g_l1);

                var svgroot = document.getElementById("svgroot");

                // Get bounding box of the SVG element for Layer_1
                g_bBox = svgroot.getBBox();

                g_l0 = frag.select("#Layer_0");
                g_l2 = frag.select("#Layer_2");
                g_l3 = frag.select("#Layer_3");
                g_l1.prepend(g_l0);
                g_l1.append(g_l2);
                g_l1.append(g_l3);

                var g_srcx, g_srcy, g_dstx, g_dsty;
                svgroot.addEventListener('click', function(event){
                    var pt = svgroot.createSVGPoint();
                    pt.x = event.x;
                    pt.y = event.y;
                    var transformed = pt.matrixTransform(svgroot.getScreenCTM().inverse());

                    // Was there a source already chosen?
                    if (!g_srcx){
                        g_srcx = Math.floor(transformed.x);
                        g_srcy = Math.floor(transformed.y);
                        s.rect(g_srcx - 2, g_srcy - 2, 4, 4).attr("fill", "red");
                    }
                    else {
                      g_dstx = Math.floor(transformed.x);
                      g_dsty = Math.floor(transformed.y);
                      // Hide the rect so the path finding doesnt feel its unwalkable
                      s.rect(g_srcx - 2, g_srcy - 2, 4, 4).attr("fill", "black");
                      renderPath(g_srcx, g_srcy, g_dstx, g_dsty);
                    }
                }
              );
            });

            function renderPath(srcx, srcy, dstx, dsty){
              // Get the svg element root
              var svgroot = document.getElementById("svgroot");

              // Create a Canvas
              var cvs = document.createElement("canvas");

              // get svg data
              var xml = new XMLSerializer().serializeToString(svgroot);
              // make it base64
              var svg64 = btoa(xml);
              var b64Start = 'data:image/svg+xml;base64,';

              // prepend a "header"
              var image64 = b64Start + svg64;

              // set it as the source of the img element
              var img = document.querySelector('img');
              img.src = image64;

              // Draw image into Canvas
              var ctx = cvs.getContext('2d');
              cvs.width = img.width;
              cvs.height = img.height;
              ctx.drawImage(img, 0, 0, img.width, img.height);

              // Delete img
              // img.parentNode.removeChild(img);

              var cols = Math.floor(g_bBox.width);
              var rows = Math.floor(g_bBox.height);
              var baseX = Math.floor(g_bBox.x);
              var baseY = Math.floor(g_bBox.y);

              console.log("Computing Grid for path finding");
              // console.log([baseX, baseY, cols, rows]);
              var pathGrid = new PF.Grid(cols + 5, rows + 5);

              var DoneFlag = 0;

              // Scan X(Y(color))
              for (i = baseX; i < (baseX + cols); i+= 1)
              {
                  for (j = baseY; j < (baseY + rows); j+= 1)
                  {
                      var pt = ctx.getImageData(i, j, 1, 1).data;

                      // Walkable points are RGB(<30,<30,<30) only
                      if (pt[0] > 30 || pt[1] > 30 || pt[2] > 30)
                      {
                          // Update path Grid
                          x = i - baseX;
                          y = j - baseY;

                          // Dest?
                          if (x == dstx && y == dsty)
                          {
                              console.log("Destination unwalkable!");
                              DoneFlag = 1;
                              break;
                          }
                          try
                          {
                              pathGrid.setWalkableAt(x, y, false);
                          }
                          catch(err)
                          {
                              console.log("Setting unwalkableij: [" + i + "][" + j + "]");
                              console.log("Setting unwalkablexy: [" + x + "][" + y + "]");
                          }
                      }
                      else {
                           //s.rect(i, j, 1, 1).attr("fill", "brown"); // shows all walkable pts
                      }
                  }
                  if (DoneFlag)
                    break;

                  if ((i % 100) == 0)
                      console.log("Done with i: " + i);
              }
              s.rect(srcx - 2, srcy - 2, 4, 4).attr("fill", "red");
              s.rect(dstx - 2, dsty - 2, 4, 4).attr("fill", "green");

              // Display floor underneath
              g_l1.prepend(g_l0);

              // Display overlay
              g_l1.append(g_l3);

              // Display overlay
              var l2 = document.getElementById("Layer_2");
              l2.parentNode.removeChild(l2);

              //g_l1.append(g_l2);
              if (DoneFlag)
                return;

              srcx -= baseX;
              srcy -= baseY;
              dstx -= baseX;
              dsty -= baseY;
              console.log("Computing path from (" + srcx + "," + srcy + ") to (" + dstx + "," + dsty + ")");

              // Check walkability
              if (!pathGrid.isWalkableAt(srcx, srcy))
                console.log("Src unwalkable; Dst not checked");
              else if (!pathGrid.isWalkableAt(dstx, dsty))
                console.log("Src walkable, Dst unwalkable");

              var pathFinder = new PF.AStarFinder({allowDiagonal: true, dontCrossCorners: true,
                heuristic: PF.Heuristic.chebyshev});
              var path = pathFinder.findPath(srcx, srcy, dstx, dsty, pathGrid);
              if (path.length){
                // Smoothen and decompress the result
                newpath0 = PF.Util.smoothenPath(pathGrid, path);
                newpath = PF.Util.expandPath(newpath0);
                console.log("Found path length: " + newpath.length);

                // Draw the path
                while (newpath.length)
                {
                    var current = newpath.shift();
                    x = current[0];
                    y = current[1];
                    r = s.rect(x + baseX, y + baseY, 1, 1);
                    r.attr("fill", "blue");
                }

                console.log("Path rendered");
              }
              else {
                console.log("Unable to find a path!");
              }
            }
            function Create2DArray(rows) {
              var arr = [];

              for (var i=0;i<rows;i++) {
                 arr[i] = [];
              }

              return arr;
            }
            </script>
        <img/>
    </body>
</html>
